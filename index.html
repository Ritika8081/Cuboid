<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cuboid </title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div class="game-container">
        <div class="shape-arena">
            <div class="goal-zone">üéØ</div>
            <div id="movingShape" class="moving-shape">
                <div id="shapeElement" class="shape-circle"></div>
            </div>
            <div class="progress-indicator">
                <div id="progressFill" class="progress-fill"></div>
            </div>
            <div id="celebration" class="celebration"></div>
        </div>
    </div>

    <div class="band-display">
        <div class="band-row">
            <span class="band-label">Delta</span>
            <div class="band-bar-container">
                <div id="deltaBar" class="band-bar delta-bar" style="width: 0%;"></div>
            </div>
            <span id="deltaValue" class="band-value">0%</span>
        </div>
        <div class="band-row">
            <span class="band-label">Theta</span>
            <div class="band-bar-container">
                <div id="thetaBar" class="band-bar theta-bar" style="width: 0%;"></div>
            </div>
            <span id="thetaValue" class="band-value">0%</span>
        </div>
        <div class="band-row">
            <span class="band-label">Alpha</span>
            <div class="band-bar-container">
                <div id="alphaBar" class="band-bar alpha-bar" style="width: 0%;"></div>
            </div>
            <span id="alphaValue" class="band-value">0%</span>
        </div>
        <div class="band-row">
            <span class="band-label">Beta</span>
            <div class="band-bar-container">
                <div id="betaBar" class="band-bar beta-bar" style="width: 0%;"></div>
            </div>
            <span id="betaValue" class="band-value">0%</span>
        </div>
        <div class="band-row">
            <span class="band-label">Gamma</span>
            <div class="band-bar-container">
                <div id="gammaBar" class="band-bar gamma-bar" style="width: 0%;"></div>
            </div>
            <span id="gammaValue" class="band-value">0%</span>
        </div>
    </div>

    <div class="control-panel updated-panel">
        <!-- Difficulty Section -->
        <div class="panel-section difficulty-section">
            <div class="section-header">
                <span class="section-title">üéØ Difficulty Level</span>
                <div class="threshold-display">
                    <span class="threshold-label">Threshold:</span>
                    <span class="value-display" id="betaThresholdValue">0.30</span>
                </div>
            </div>

            <div class="difficulty-buttons">
                <button class="difficulty-btn" data-level="beginner" data-threshold="0.30" data-stepforward="15"
                    data-stepback="3">
                    <span class="btn-icon beginner-icon"></span>
                    <span class="btn-text">Beginner</span>

                </button>

                <button class="difficulty-btn" data-level="easy" data-threshold="0.30" data-stepforward="13"
                    data-stepback="5">
                    <span class="btn-icon easy-icon"></span>
                    <span class="btn-text">Easy</span>

                </button>

                <button class="difficulty-btn" data-level="medium" data-threshold="0.30" data-stepforward="10"
                    data-stepback="6">
                    <span class="btn-icon medium-icon"></span>
                    <span class="btn-text">Medium</span>

                </button>

                <button class="difficulty-btn" data-level="hard" data-threshold="0.30" data-stepforward="8"
                    data-stepback="7">
                    <span class="btn-icon hard-icon"></span>
                    <span class="btn-text">Hard</span>

                </button>

                <button class="difficulty-btn" data-level="pro" data-threshold="0.30" data-stepforward="7"
                    data-stepback="8">
                    <span class="btn-icon pro-icon"></span>
                    <span class="btn-text">Pro</span>

                </button>
            </div>
        </div>

        <div class="panel-divider"></div>

        <!-- Device Section -->
        <div class="panel-section device-section">
            <div class="section-header">
                <span class="section-title">üîå Device Control</span>
                <div class="status-indicator">
                    <div class="status-dot" id="statusDot"></div>
                    <div class="status" id="statusText">Not connected</div>
                </div>
            </div>
            <div class="control-button-grid">
                <button id="connectBtn" class="control-btn connect-btn">
                    <span class="btn-text">Connect</span>
                </button>
                <button id="disconnectBtn" class="control-btn disconnect-btn" disabled>
                    <span class="btn-text">Disconnect</span>
                </button>
                <button id="startBtn" class="control-btn start-btn" disabled>
                    <span class="btn-text">Start Stream</span>
                </button>
                <button id="stopBtn" class="control-btn stop-btn" disabled>
                    <span class="btn-text">Stop Stream</span>
                </button>
            </div>
        </div>
    </div>


    <!-- Add this in the body section, just after the band-display div -->
    <div class="goal-counter">
        Goals: <span id="goalCount">0</span>/5
    </div>
    <script>
        // Shape management
        const shapes = ['cuboid', 'box'];
        let stepPosition = 0;
        let forwardStep = 10;
        let backStep = 5;
        let lastAboveThresholdTime = null;
        let lastBelowThresholdTime = null;
        let betaMaxDuringCalibration = 0;
        let calibrationStartTime = null;
        let calibrationInterval = null;


        let currentShape = '';
        let shapePosition = 0; // 0 = bottom, 100 = top
        let goalReached = false;
        let celebrationActive = false;

        let goalCount = 0;
        let gameWon = false;

        // DOM elements
        const movingShape = document.getElementById('movingShape');
        const shapeElement = document.getElementById('shapeElement');
        const progressFill = document.getElementById('progressFill');
        const celebration = document.getElementById('celebration');
        const difficultyButtons = document.querySelectorAll('.difficulty-btn');
        const betaThresholdValue = document.getElementById('betaThresholdValue');
        const connectBtn = document.getElementById("connectBtn");
        const disconnectBtn = document.getElementById("disconnectBtn");
        const startBtn = document.getElementById("startBtn");
        const stopBtn = document.getElementById("stopBtn");
        const statusText = document.getElementById("statusText");

        // BLE constants
        const SERVICE_UUID = "4fafc201-1fb5-459e-8fcc-c5c9c331914b";
        const DATA_CHAR_UUID = "beb5483e-36e1-4688-b7f5-ea07361b26a8";
        const CONTROL_CHAR_UUID = "0000ff01-0000-1000-8000-00805f9b34fb";
        const SINGLE_SAMPLE_LEN = 7, BLOCK_COUNT = 10;
        const NEW_PACKET_LEN = SINGLE_SAMPLE_LEN * BLOCK_COUNT;

        // EEG processing constants
        const FFT_SIZE = 256;
        const SAMPLE_RATE = 500;
        const FREQ_RESOLUTION = SAMPLE_RATE / FFT_SIZE;
        const DELTA_RANGE = [0.5, 4];
        const THETA_RANGE = [4, 8];
        const ALPHA_RANGE = [8, 12];
        const BETA_RANGE = [12, 30];
        const GAMMA_RANGE = [30, 45];

        // Variables for BLE connection
        let device = null, server = null, controlChar = null, dataChar = null;
        let streaming = false, connected = false;
        let prevSampleCounter = null, samplesReceived = 0;

        // Variables for EEG processing
        let fftBuffer = new Array(FFT_SIZE).fill(0);
        let filterStateCh0 = { z1: 0, z2: 0, x1: 0 };
        let betaThreshold = 0.40;

        // Add stepPosition reset in initializeShape
        function initializeShape() {
            currentShape = shapes[Math.floor(Math.random() * shapes.length)];
            shapeElement.className = `shape-${currentShape}`;
            stepPosition = 0;
            goalReached = false;
            celebrationActive = false;
            updateShapePosition();

            const goalZone = document.querySelector('.goal-zone');
            goalZone.className = 'goal-zone';

            console.log(`New shape initialized: ${currentShape}`);
        }
        function startCalibrationPhase() {
            betaMaxDuringCalibration = 0;
            calibrationStartTime = performance.now();
            smoother.clear();

            // Remove any existing overlay
            const oldOverlay = document.getElementById("calibrationOverlayJS");
            if (oldOverlay) oldOverlay.remove();

            // Create overlay
            const overlay = document.createElement("div");
            overlay.id = "calibrationOverlayJS";
            overlay.style.position = "fixed";
            overlay.style.top = 0;
            overlay.style.left = 0;
            overlay.style.width = "100vw";
            overlay.style.height = "100vh";
            overlay.style.background = "rgba(30,39,46,0.85)";
            overlay.style.display = "flex";
            overlay.style.justifyContent = "center";
            overlay.style.alignItems = "center";
            overlay.style.zIndex = 2000;

            // Create calibration box
            const box = document.createElement("div");
            box.style.background = "#fff";
            box.style.borderRadius = "24px";
            box.style.padding = "36px 32px 28px 32px";
            box.style.boxShadow = "0 8px 32px rgba(30,200,180,0.18)";
            box.style.textAlign = "center";
            box.style.minWidth = "320px";
            box.style.position = "relative";
            box.style.animation = "popIn 0.5s";
            box.innerHTML = `
        <div style="
            margin: 0 auto 18px auto;
            border: 6px solid #f1f1f1;
            border-top: 6px solid #48dbfb;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            animation: spin 1s linear infinite;
        "></div>
        <h2 style="color:#10ac84;margin-bottom:12px;font-size:1.5em;font-weight:bold;">üß† Calibrating Your Brainwaves...</h2>
        <p style="color:#222f3e;font-size:1.1em;margin:10px 0;">Please stay focused. Measuring beta activity.</p>
        <p id="calibrationCountdownJS" style="font-size:2.5em;color:#48dbfb;font-weight:bold;margin-top:18px;letter-spacing:2px;">5</p>
    `;
            overlay.appendChild(box);
            document.body.appendChild(overlay);

            // Spinner animation
            const style = document.createElement('style');
            style.innerHTML = `
    @keyframes spin { 0% { transform: rotate(0deg);} 100% { transform: rotate(360deg);} }
    @keyframes popIn { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }
    `;
            document.head.appendChild(style);

            let secondsLeft = 5;
            const countdown = document.getElementById("calibrationCountdownJS");
            countdown.textContent = secondsLeft;

            const timer = setInterval(() => {
                secondsLeft--;
                countdown.textContent = secondsLeft;
                if (secondsLeft <= 0) {
                    clearInterval(timer);
                }
            }, 1000);

            calibrationInterval = setInterval(() => {
                const smoothBeta = smoother.getSmoothed('beta');
                if (smoothBeta > betaMaxDuringCalibration) {
                    betaMaxDuringCalibration = smoothBeta;
                }

                const now = performance.now();
                if (now - calibrationStartTime >= 5000) {
                    clearInterval(calibrationInterval);
                    // Remove overlay
                    overlay.remove();
                    style.remove();
                    applyCalibratedThreshold();
                }
            }, 100);
        }

        function applyCalibratedThreshold() {
            betaThreshold = betaMaxDuringCalibration;
            thresholdDisplay.textContent = betaThreshold.toFixed(2);
            console.log("Calibration complete. Beta threshold set to:", betaThreshold.toFixed(2));
            alert(`Calibration complete!\nBeta threshold set to: ${betaThreshold.toFixed(2)}`);
            // Now start the shape game
            initializeShape();
        }
        // Modified updateShapePosition to use stepPosition
        function updateShapePosition() {
            const maxHeight = movingShape.parentElement.clientHeight - 140;
            const bottomPosition = 20 + (stepPosition / 100) * maxHeight;
            movingShape.style.bottom = `${bottomPosition}px`;
            progressFill.style.height = `${stepPosition}%`;
        }

        function updateStepPosition(delta) {
            stepPosition = Math.max(0, Math.min(100, stepPosition + delta));
            updateShapePosition();
            if (stepPosition >= 100 && !goalReached) {
                goalReached = true;
                triggerCelebration();
            }
        }

        function triggerCelebration() {
            if (celebrationActive) return;
            celebrationActive = true;

            const goalZone = document.querySelector('.goal-zone');
            goalZone.className = 'goal-zone';
            goalZone.classList.add(`${currentShape.replace(/\s+/g, '-').toLowerCase()}-color`);

            // Merge shape into goal
            shapeElement.classList.add('shape-merging');

            // After merge animation
            setTimeout(() => {
                shapeElement.style.visibility = 'hidden'; // hide shape after merging

                // Increase goal count
                if (!gameWon) {
                    goalCount++;
                    document.getElementById('goalCount').textContent = goalCount;

                    if (goalCount >= 5) {
                        gameWon = true;
                        showWinningMessage();
                        return;
                    }
                }

                createFireworks();

                const successMsg = document.createElement('div');
                successMsg.className = 'success-message';
                successMsg.innerHTML = 'üéâ GOAL ACHIEVED! üéâ<br><small>Great focus!</small>';
                celebration.appendChild(successMsg);

                setTimeout(() => {
                    celebration.innerHTML = '';
                    celebrationActive = false;

                    // Reset visuals
                    setTimeout(() => {
                        shapePosition = 0;
                        goalReached = false;
                        goalZone.className = 'goal-zone';

                        // Reset shape
                        shapeElement.classList.remove('shape-merging');
                        shapeElement.style.visibility = 'visible';
                        updateShapePosition();
                        initializeShape();
                    }, 500); // slightly shorter delay
                }, 2500);
            }, 600); // match animation time
        }



        function showWinningMessage() {
            const winningMsg = document.createElement('div');
            winningMsg.className = 'winning-message';
            winningMsg.innerHTML = `
        üèÜ YOU WIN! üèÜ<br>
        <small>Amazing focus control!</small><br><br>
        <button id="playAgainBtn" style="
            margin-top: 20px;
            padding: 12px 32px;
            font-size: 1.2em;
            background: linear-gradient(90deg, #48dbfb, #1dd1a1);
            color: #fff;
            border: none;
            border-radius: 30px;
            box-shadow: 0 4px 16px rgba(30,200,180,0.15);
            cursor: pointer;
            transition: background 0.3s, transform 0.2s;
        ">üîÑ Play Again</button>
    `;
            document.body.appendChild(winningMsg);

            const playAgainBtn = document.getElementById('playAgainBtn');
            playAgainBtn.addEventListener('mouseover', () => {
                playAgainBtn.style.background = 'linear-gradient(90deg, #1dd1a1, #48dbfb)';
                playAgainBtn.style.transform = 'scale(1.05)';
            });
            playAgainBtn.addEventListener('mouseout', () => {
                playAgainBtn.style.background = 'linear-gradient(90deg, #48dbfb, #1dd1a1)';
                playAgainBtn.style.transform = 'scale(1)';
            });
            playAgainBtn.addEventListener('click', () => {
                window.location.reload();
            });
        }


        // Call initializeShape at the end of the script to start the game
        initializeShape();
        function createFireworks() {
            const colors = ['#ff6b6b', '#feca57', '#48dbfb', '#1dd1a1', '#ff9ff3'];
            const arenaRect = movingShape.parentElement.getBoundingClientRect();

            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    const firework = document.createElement('div');
                    firework.className = 'firework';
                    firework.style.background = colors[Math.floor(Math.random() * colors.length)];
                    firework.style.left = Math.random() * 100 + '%';
                    firework.style.top = Math.random() * 100 + '%';
                    celebration.appendChild(firework);

                    setTimeout(() => firework.remove(), 1000);
                }, i * 100);
            }
        }

        // Notch filter for 50Hz noise
        class Notch {
            constructor() {
                this.z1_1 = 0; this.z2_1 = 0;
                this.x_1 = 0;
                this.currentSamplingRate = 500;
            }
            setSamplingRate(rate) { this.currentSamplingRate = rate; }
            process(input, type) {
                if (!type) return input;
                let output = input;
                if (this.currentSamplingRate === 500 && type === 1) {
                    this.x_1 = output - (-1.56858163 * this.z1_1) - (0.96424138 * this.z2_1);
                    output = 0.96508099 * this.x_1 + -1.56202714 * this.z1_1 + 0.96508099 * this.z2_1;
                    this.z2_1 = this.z1_1;
                    this.z1_1 = this.x_1;
                }
                return output;
            }
        }
        let notchFilterCh0 = new Notch();
        notchFilterCh0.setSamplingRate(500);

        // FFT implementation
        class FFT {
            size;
            cosTable;
            sinTable;
            constructor(size) {
                this.size = size;
                this.cosTable = new Float32Array(size / 2);
                this.sinTable = new Float32Array(size / 2);
                for (let i = 0; i < size / 2; i++) {
                    this.cosTable[i] = Math.cos(-2 * Math.PI * i / size);
                    this.sinTable[i] = Math.sin(-2 * Math.PI * i / size);
                }
            }
            fft(real, imag) {
                const n = this.size;
                let j = 0;
                for (let i = 0; i < n - 1; i++) {
                    if (i < j) {
                        [real[i], real[j]] = [real[j], real[i]];
                        [imag[i], imag[j]] = [imag[j], imag[i]];
                    }
                    let k = n / 2;
                    while (k <= j) { j -= k; k /= 2; }
                    j += k;
                }
                for (let len = 2; len <= n; len *= 2) {
                    const half = len / 2;
                    for (let i = 0; i < n; i += len) {
                        for (let j = i, k = 0; j < i + half; j++, k++) {
                            const tRe = real[j + half] * this.cosTable[k] - imag[j + half] * this.sinTable[k];
                            const tIm = real[j + half] * this.sinTable[k] + imag[j + half] * this.cosTable[k];
                            real[j + half] = real[j] - tRe;
                            imag[j + half] = imag[j] - tIm;
                            real[j] += tRe;
                            imag[j] += tIm;
                        }
                    }
                }
            }
            computeMagnitudes(input) {
                const real = new Float32Array(this.size);
                const imag = new Float32Array(this.size);
                real.set(input);
                this.fft(real, imag);
                const mags = new Float32Array(this.size / 2);
                for (let i = 0; i < mags.length; i++) {
                    mags[i] = Math.hypot(real[i], imag[i]) / (this.size / 2);
                }
                return mags;
            }
        }

        const fftProcessor = new FFT(FFT_SIZE);


        const thresholdDisplay = document.getElementById('betaThresholdValue');

        // ...existing code...

        function setDifficulty(level, displayValue, threshold) {
            betaThreshold = 0.30; // Always set to 0.30
            thresholdDisplay.textContent = "0.30";

            difficultyButtons.forEach(btn => btn.classList.remove('active'));

            const targetBtn = Array.from(difficultyButtons).find(
                btn => btn.dataset.level === level
            );
            if (targetBtn) {
                forwardStep = parseInt(targetBtn.dataset.stepforward || '10');
                backStep = parseInt(targetBtn.dataset.stepback || '5');
                targetBtn.classList.add('active');
            }
        }

        // Attach event listeners to all buttons
        difficultyButtons.forEach(button => {
            button.addEventListener('click', () => {
                const level = button.dataset.level;
                setDifficulty(level, "0.30", 0.30); // Always use 0.30
            });
        });

        // Set default to easy
        const defaultButton = document.querySelector('.difficulty-btn[data-level="easy"]');
        if (defaultButton) {
            const level = defaultButton.dataset.level;
            setDifficulty(level, "0.30", 0.30); // Always use 0.30
        }



        // Attach event listeners to all buttons
        difficultyButtons.forEach(button => {
            button.addEventListener('click', () => {
                const level = button.dataset.level;
                const threshold = parseFloat(button.dataset.threshold);
                const displayValue = button.querySelector('.btn-value').textContent.trim();
                setDifficulty(level, displayValue, threshold);
            });
        });


        // Utility functions
        function normalizeSample(sample) {
            const a = 4096;
            return (sample - a / 2) * (2 / a);
        }

        function applyFilter(input, state) {
            state.x1 = input - (-1.47548044 * state.z1) - (0.58691951 * state.z2);
            const output = 0.02785977 * state.x1 + 0.05571953 * state.z1 + 0.02785977 * state.z2;
            state.z2 = state.z1;
            state.z1 = state.x1;
            return output;
        }

        function calculateBandPower(fftMagnitudes, freqRange) {
            const [startFreq, endFreq] = freqRange;
            const startIndex = Math.max(1, Math.floor(startFreq / FREQ_RESOLUTION));
            const endIndex = Math.min(Math.floor(endFreq / FREQ_RESOLUTION), fftMagnitudes.length - 1);
            let power = 0;
            for (let i = startIndex; i <= endIndex; i++) {
                power += fftMagnitudes[i] * fftMagnitudes[i];
            }
            return power;
        }

        // Band smoother class
        class BandSmoother {
            constructor(bufferSize) {
                this.bufferSize = bufferSize;
                this.buffers = {};
                this.sums = {};
                this.index = 0;

                ['delta', 'theta', 'alpha', 'beta', 'gamma'].forEach(band => {
                    this.buffers[band] = new Array(bufferSize).fill(0);
                    this.sums[band] = 0;
                });
            }

            updateAll(bandValues) {
                for (const band in bandValues) {
                    const val = bandValues[band];
                    this.sums[band] -= this.buffers[band][this.index];
                    this.sums[band] += val;
                    this.buffers[band][this.index] = val;
                }
                this.index = (this.index + 1) % this.bufferSize;
            }

            getSmoothed(band) {
                return this.sums[band] / this.bufferSize;
            }

            clear() {
                for (const band in this.buffers) {
                    this.buffers[band].fill(0);
                    this.sums[band] = 0;
                }
                this.index = 0;
            }
        }

        const smoother = new BandSmoother(128);

        // Replace updateBarGraph logic to use time thresholds
        function updateBarGraph(deltaP, thetaP, alphaP, betaP, gammaP) {
            const total = deltaP + thetaP + alphaP + betaP + gammaP;
            if (total <= 0) return;

            const rels = {
                delta: deltaP / total,
                theta: thetaP / total,
                alpha: alphaP / total,
                beta: betaP / total,
                gamma: gammaP / total
            };

            smoother.updateAll(rels);

            const smooth = {
                delta: smoother.getSmoothed('delta'),
                theta: smoother.getSmoothed('theta'),
                alpha: smoother.getSmoothed('alpha'),
                beta: smoother.getSmoothed('beta'),
                gamma: smoother.getSmoothed('gamma')
            };

            ['delta', 'theta', 'alpha', 'beta', 'gamma'].forEach(band => {
                const pct = Math.round(smooth[band] * 100);
                document.getElementById(`${band}Bar`).style.width = `${pct}%`;
                document.getElementById(`${band}Value`).textContent = `${pct}%`;
            });

            const currentTime = performance.now();

            if (smooth.beta >= betaThreshold) {
                if (!lastAboveThresholdTime) lastAboveThresholdTime = currentTime;
                if (currentTime - lastAboveThresholdTime >= 3000) {
                    updateStepPosition(forwardStep);
                    lastAboveThresholdTime = null;
                    lastBelowThresholdTime = null;
                }
            } else {
                if (!lastBelowThresholdTime) lastBelowThresholdTime = currentTime;
                if (currentTime - lastBelowThresholdTime >= 3000) {
                    updateStepPosition(-backStep);
                    lastBelowThresholdTime = null;
                    lastAboveThresholdTime = null;
                }
            }
        }

        function processFFT() {
            if (fftBuffer.length < FFT_SIZE) return;
            const fftMags = fftProcessor.computeMagnitudes(fftBuffer);
            const deltaPower = calculateBandPower(fftMags, DELTA_RANGE);
            const thetaPower = calculateBandPower(fftMags, THETA_RANGE);
            const alphaPower = calculateBandPower(fftMags, ALPHA_RANGE);
            const betaPower = calculateBandPower(fftMags, BETA_RANGE);
            const gammaPower = calculateBandPower(fftMags, GAMMA_RANGE);
            updateBarGraph(deltaPower, thetaPower, alphaPower, betaPower, gammaPower);
        }

        function updateData(eegValue) {
            eegValue = notchFilterCh0.process(eegValue, 1);
            fftBuffer.push(eegValue);
            if (fftBuffer.length > FFT_SIZE) fftBuffer.shift();
            if (samplesReceived % 10 === 0) processFFT();
        }

        function processSample(dataView) {
            if (dataView.byteLength !== SINGLE_SAMPLE_LEN) return;

            const sampleCounter = dataView.getUint8(0);
            prevSampleCounter = sampleCounter;

            // Read EEG channel
            const rawEEG = dataView.getInt16(1, false);

            // Process EEG
            const normEEG = normalizeSample(Math.max(0, Math.min(4095, rawEEG)));
            const filteredEEG = applyFilter(normEEG, filterStateCh0);
            updateData(filteredEEG);
            samplesReceived++;
        }

        function handleIncomingSamples(event) {
            const value = event.target.value;
            if (value.byteLength === NEW_PACKET_LEN) {
                for (let i = 0; i < NEW_PACKET_LEN; i += SINGLE_SAMPLE_LEN) {
                    const sampleBuf = value.buffer.slice(i, i + SINGLE_SAMPLE_LEN);
                    processSample(new DataView(sampleBuf));
                }
            } else if (value.byteLength === SINGLE_SAMPLE_LEN) {
                processSample(new DataView(value.buffer));
            }
        }
        function clearBarGraph() {
            // for each band, reset width and label
            ['delta', 'theta', 'alpha', 'beta', 'gamma'].forEach(band => {
                document.getElementById(`${band}Bar`).style.width = '0%';
                document.getElementById(`${band}Value`).textContent = '';  // blank instead of ‚Äú0%‚Äù
            });
        }

        function updateButtonStates() {
            connectBtn.disabled = connected || streaming;
            disconnectBtn.disabled = !connected;
            startBtn.disabled = !connected || streaming;
            stopBtn.disabled = !streaming;

            if (!connected) statusText.textContent = "Not connected";
            else if (!streaming) statusText.textContent = "Connected but not streaming";
            else statusText.textContent = "Connected and streaming data";
        }

        async function connectBLE() {
            try {
                if (!navigator.bluetooth) {
                    alert("Web Bluetooth API not available. Use Chrome or Edge.");
                    return;
                }
                device = await navigator.bluetooth.requestDevice({
                    filters: [{ namePrefix: "NPG" }],
                    optionalServices: [SERVICE_UUID],
                });
                server = await device.gatt.connect();
                const service = await server.getPrimaryService(SERVICE_UUID);
                controlChar = await service.getCharacteristic(CONTROL_CHAR_UUID);
                dataChar = await service.getCharacteristic(DATA_CHAR_UUID);
                connected = true; streaming = false;
                fftBuffer = new Array(FFT_SIZE).fill(0);
                updateButtonStates();
                console.log("Device connected.");
            } catch (err) {
                console.log("Error:", err);
                alert("Connection error: " + err);
            }
        }

        async function disconnectBLE() {
            try {
                if (device && device.gatt.connected) {
                    if (streaming) await stopStream();
                    device.gatt.disconnect();
                }
                connected = false;
                streaming = false;
                updateButtonStates();
                clearBarGraph();
                stepPosition = 0;
                updateShapePosition();
                console.log("Device disconnected.");
            } catch (err) {
                console.log("Error disconnecting:", err);
            }
        }

        async function startStream() {
            try {
                if (!dataChar || !controlChar) return;

                await controlChar.writeValue(new TextEncoder().encode("START"));
                await dataChar.startNotifications();
                dataChar.addEventListener("characteristicvaluechanged", handleIncomingSamples);
                streaming = true;
                updateButtonStates();
                console.log("Streaming started.");

                startCalibrationPhase();  // ‚¨ÖÔ∏è initiate the 5-second beta calibration
            } catch (err) {
                console.log("Error starting stream:", err);
                alert("Error starting stream: " + err);
            }
        }


        async function stopStream() {
            try {
                if (dataChar && streaming) {
                    await dataChar.stopNotifications();
                    dataChar.removeEventListener("characteristicvaluechanged", handleIncomingSamples);
                    streaming = false;
                    updateButtonStates();
                    console.log("Streaming stopped.");
                }
            } catch (err) {
                console.log("Error stopping stream:", err);
            }
        }

        // Event listeners for buttons
        connectBtn.addEventListener("click", connectBLE);
        disconnectBtn.addEventListener("click", disconnectBLE);
        startBtn.addEventListener("click", startStream);
        stopBtn.addEventListener("click", stopStream);
    </script>
</body>

</html>