<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cuboid </title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div class="game-container">
        <div class="shape-arena">
            <div class="goal-zone"><span class="goal-emoji">üéØ</span></div>
            <div id="movingShape" class="moving-shape">
                <div id="shapeElement" class="shape-circle"></div>
            </div>
            <div class="progress-indicator">
                <div id="progressFill" class="progress-fill"></div>
                <div id="progressPercentage" class="progress-percentage">0%</div>
            </div>

            <div id="celebration" class="celebration"></div>
        </div>
    </div>

    <div class="band-display">
        <div class="band-row">
            <span class="band-label">Delta</span>
            <div class="band-bar-container">
                <div id="deltaBar" class="band-bar delta-bar" style="width: 0%;"></div>
            </div>
            <span id="deltaValue" class="band-value">0%</span>
        </div>
        <div class="band-row">
            <span class="band-label">Theta</span>
            <div class="band-bar-container">
                <div id="thetaBar" class="band-bar theta-bar" style="width: 0%;"></div>
            </div>
            <span id="thetaValue" class="band-value">0%</span>
        </div>
        <div class="band-row">
            <span class="band-label">Alpha</span>
            <div class="band-bar-container">
                <div id="alphaBar" class="band-bar alpha-bar" style="width: 0%;"></div>
            </div>
            <span id="alphaValue" class="band-value">0%</span>
        </div>
        <div class="band-row">
            <span class="band-label">Beta</span>
            <div class="band-bar-container">
                <div id="betaBar" class="band-bar beta-bar" style="width: 0%;"></div>
            </div>
            <span id="betaValue" class="band-value">0%</span>
        </div>
        <div class="band-row">
            <span class="band-label">Gamma</span>
            <div class="band-bar-container">
                <div id="gammaBar" class="band-bar gamma-bar" style="width: 0%;"></div>
            </div>
            <span id="gammaValue" class="band-value">0%</span>
        </div>
    </div>

    <div id="rulesModal" class="rules-modal">
        <div class="rules-content-wide">
            <span class="close-btn" id="closeRules">&times;</span>

            <h2 class="modal-header">Welcome To Cuboid!</h2>

            <div class="rules-columns">
                <!-- Left Column -->
                <div class="rules-left-column">
                    <div class="steps-section">
                        <h3>üìã Steps</h3>
                        <ol class="steps-list">
                            <li>Connect your NPG Lite device.</li>
                            <li>Adjust the beta threshold using the slider.</li>
                            <li>Select a difficulty level.</li>
                            <li>Stay focused to rise ‚Äî lose focus and you'll fall!</li>
                        </ol>
                    </div>

                    <div class="difficulty-section">
                        <h3>üéÆ Difficulty Levels</h3>

                        <!-- Table for larger screens -->
                        <div class="difficulty-table-desktop">
                            <div class="table-wrapper">
                                <table class="difficulty-table">
                                    <thead>
                                        <tr>
                                            <th>Level</th>
                                            <th>Up</th>
                                            <th>Down</th>
                                            <th>Notes</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td><strong>Beginner</strong></td>
                                            <td>15</td>
                                            <td>3</td>
                                            <td>Quick progress, low penalty</td>
                                        </tr>
                                        <tr>
                                            <td><strong>Easy</strong></td>
                                            <td>13</td>
                                            <td>5</td>
                                            <td>Moderate penalty</td>
                                        </tr>
                                        <tr>
                                            <td><strong>Medium</strong></td>
                                            <td>10</td>
                                            <td>6</td>
                                            <td>Balanced challenge</td>
                                        </tr>
                                        <tr>
                                            <td><strong>Hard</strong></td>
                                            <td>8</td>
                                            <td>7</td>
                                            <td>High penalty</td>
                                        </tr>
                                        <tr>
                                            <td><strong>Pro</strong></td>
                                            <td>7</td>
                                            <td>8</td>
                                            <td>Strict mode</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>


                    </div>
                </div>

                <!-- Right Column -->
                <div class="rules-right-column">
                    <div class="colors-section">
                        <h3>üé® Progress Colors</h3>
                        <ul class="color-list">
                            <li><span class="color-indicator red"></span> Red: Low focus (0-30%)</li>
                            <li><span class="color-indicator orange"></span> Orange: Warming up (30-60%)</li>
                            <li><span class="color-indicator yellow"></span> Yellow: Midway (60-90%)</li>
                            <li><span class="color-indicator green"></span> Green: Near goal (90-100%)</li>
                        </ul>
                    </div>

                    <div class="objective-section">
                        <h3>üèÜ Game Objective</h3>
                        <div class="objective-box">
                            <p>Reach the goal üéØ <strong>5 times</strong> to win!</p>

                            <div class="stats-mini">
                                <span>‚è±Ô∏è Hold focus for 2 seconds to move up</span>
                                <span>üò¥ Lose focus for 2 seconds to move down</span>
                            </div>
                        </div>
                    </div>

                    <div class="game-start-section">
                        <p class="motivational-text">Train your brain. Improve focus. Enjoy the journey.</p>
                        <button id="startGameBtn" class="start-game-btn">Start Game</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="control-panel updated-panel">
        <!-- Difficulty Section -->

        <div class="panel-section difficulty-section">
            <div class="section-header">
                <span class="section-title">üéØ Difficulty Level</span>
                <button id="rulesBtn" class="rules-button margin-left:10px">‚ùìRules</button>
                <div class="threshold-controls">
                    <span class="threshold-label">Beta Threshold:</span>
                    <div class="slider-container">
                        <input type="range" id="betaSlider" min="0.1" max="1.0" step="0.01" value="0.30"
                            class="threshold-slider">
                        <span class="value-display" id="betaThresholdValue">0.30</span>
                    </div>
                </div>
            </div>


            <div class="difficulty-buttons">

                <button class="difficulty-btn" data-level="beginner" data-stepforward="15" data-stepback="3">
                    <span class="btn-icon beginner-icon"></span>
                    <span class="btn-text">Beginner</span>

                </button>

                <button class="difficulty-btn" data-level="easy" data-stepforward="13" data-stepback="5">
                    <span class="btn-icon easy-icon"></span>
                    <span class="btn-text">Easy</span>

                </button>

                <button class="difficulty-btn" data-level="medium" data-threshold="0.30" data-stepforward="10"
                    data-stepback="6">
                    <span class="btn-icon medium-icon"></span>
                    <span class="btn-text">Medium</span>

                </button>

                <button class="difficulty-btn" data-level="hard" data-threshold="0.30" data-stepforward="8"
                    data-stepback="7">
                    <span class="btn-icon hard-icon"></span>
                    <span class="btn-text">Hard</span>

                </button>

                <button class="difficulty-btn" data-level="pro" data-threshold="0.30" data-stepforward="7"
                    data-stepback="8">
                    <span class="btn-icon pro-icon"></span>
                    <span class="btn-text">Pro</span>

                </button>
            </div>
        </div>

        <div class="panel-divider"></div>

        <!-- Device Section -->
        <div class="panel-section device-section">
            <div class="section-header">
                <span class="section-title">üîå Device Control</span>
                <div class="status-indicator">
                    <div class="status-dot" id="statusDot"></div>
                    <div class="status" id="statusText">Not connected</div>
                </div>
            </div>
            <div class="control-button-grid">
                <button id="connectBtn" class="control-btn connect-btn">
                    <span class="btn-text">Connect</span>
                </button>
                <button id="disconnectBtn" class="control-btn disconnect-btn" disabled>
                    <span class="btn-text">Disconnect</span>
                </button>
                <button id="startBtn" class="control-btn start-btn" disabled>
                    <span class="btn-text">Start</span>
                </button>
                <button id="stopBtn" class="control-btn stop-btn" disabled>
                    <span class="btn-text">Stop</span>
                </button>
            </div>
        </div>
    </div>


    <!-- Add this in the body section, just after the band-display div -->
    <div class="goal-counter">
        Goals: <span id="goalCount">0</span>/5
    </div>
    <script>
        // Shape management
        const shapes = ['cuboid', 'box'];
        let stepPosition = 0;
        let forwardStep = 10;
        let backStep = 5;
        let lastAboveThresholdTime = null;
        let lastBelowThresholdTime = null;
        let betaMaxDuringCalibration = 0;
        let calibrationStartTime = null;
        let calibrationInterval = null;


        let currentShape = '';
        let shapePosition = 0; // 0 = bottom, 100 = top
        let goalReached = false;
        let celebrationActive = false;

        let goalCount = 0;
        let gameWon = false;

        // DOM elements
        const movingShape = document.getElementById('movingShape');
        const shapeElement = document.getElementById('shapeElement');
        const progressFill = document.getElementById('progressFill');
        const celebration = document.getElementById('celebration');
        const difficultyButtons = document.querySelectorAll('.difficulty-btn');
        const betaThresholdValue = document.getElementById('betaThresholdValue');
        const connectBtn = document.getElementById("connectBtn");
        const disconnectBtn = document.getElementById("disconnectBtn");
        const startBtn = document.getElementById("startBtn");
        const stopBtn = document.getElementById("stopBtn");
        const statusText = document.getElementById("statusText");
        let shapeMovementAllowed = true; // new flag

        // BLE constants
        const SERVICE_UUID = "4fafc201-1fb5-459e-8fcc-c5c9c331914b";
        const DATA_CHAR_UUID = "beb5483e-36e1-4688-b7f5-ea07361b26a8";
        const CONTROL_CHAR_UUID = "0000ff01-0000-1000-8000-00805f9b34fb";
        const SINGLE_SAMPLE_LEN = 7, BLOCK_COUNT = 10;
        const NEW_PACKET_LEN = SINGLE_SAMPLE_LEN * BLOCK_COUNT;

        // EEG processing constants
        const FFT_SIZE = 256;
        const SAMPLE_RATE = 500;
        const FREQ_RESOLUTION = SAMPLE_RATE / FFT_SIZE;
        const DELTA_RANGE = [0.5, 4];
        const THETA_RANGE = [4, 8];
        const ALPHA_RANGE = [8, 12];
        const BETA_RANGE = [12, 30];
        const GAMMA_RANGE = [30, 45];

        // Variables for BLE connection
        let device = null, server = null, controlChar = null, dataChar = null;
        let streaming = false, connected = false;
        let prevSampleCounter = null, samplesReceived = 0;

        // Variables for EEG processing
        let fftBuffer = new Array(FFT_SIZE).fill(0);
        let filterStateCh0 = { z1: 0, z2: 0, x1: 0 };
        let betaThreshold = 0.40;

        const rulesBtn = document.getElementById("rulesBtn");
        const rulesModal = document.getElementById("rulesModal");
        const closeRules = document.getElementById("closeRules");
        const startGameBtn = document.getElementById("startGameBtn");

        // Function to prevent body scroll
        function preventBodyScroll() {
            document.body.style.overflow = 'hidden';
        }

        // Function to restore body scroll
        function restoreBodyScroll() {
            document.body.style.overflow = '';
        }

        // Show modal automatically when page loads
        document.addEventListener('DOMContentLoaded', function () {
            // Small delay to ensure everything is loaded
            setTimeout(() => {
                rulesModal.classList.add("show");
                preventBodyScroll();
            }, 500);
        });

        // Update existing event listeners
        rulesBtn.addEventListener("click", () => {
            rulesModal.classList.add("show");
            preventBodyScroll();
        });

        closeRules.addEventListener("click", () => {
            rulesModal.classList.remove("show");
            restoreBodyScroll();
        });

        // Add start game button functionality if it doesn't exist
        if (document.getElementById("startGameBtn")) {
            document.getElementById("startGameBtn").addEventListener("click", () => {
                rulesModal.classList.remove("show");
                restoreBodyScroll();

                // Auto-connect and start if not already connected
                if (!connected) {
                    connectBLE().then(() => {
                        if (connected) {
                            setTimeout(() => {
                                startStream();
                            }, 1000);
                        }
                    }).catch(err => {
                        console.log("Auto-connect failed:", err);
                        // Just close modal if connection fails
                    });
                } else if (!streaming) {
                    startStream();
                }
            });
        }

        window.addEventListener("click", (e) => {
            if (e.target === rulesModal) {
                rulesModal.classList.remove("show");
                restoreBodyScroll();
            }
        });

        // Handle escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && rulesModal.classList.contains('show')) {
                rulesModal.classList.remove("show");
                restoreBodyScroll();
            }
        });

        // Add stepPosition reset in initializeShape
        function initializeShape() {
            currentShape = shapes[Math.floor(Math.random() * shapes.length)];
            shapeElement.className = `shape-${currentShape}`;
            stepPosition = 0;
            goalReached = false;
            celebrationActive = false;
            updateShapePosition();

            const goalZone = document.querySelector('.goal-zone');
            goalZone.className = 'goal-zone';

            console.log(`New shape initialized: ${currentShape}`);
        }
        function startCalibrationPhase() {
            shapeMovementAllowed = false;
            betaMaxDuringCalibration = 0;
            calibrationStartTime = performance.now();
            smoother.clear();

            // Remove any existing overlay
            const oldOverlay = document.getElementById("calibrationOverlayJS");
            if (oldOverlay) oldOverlay.remove();

            // Store all smoothed beta values during calibration
            const betaValues = [];

            // Create overlay
            const overlay = document.createElement("div");
            overlay.id = "calibrationOverlayJS";
            overlay.style.position = "fixed";
            overlay.style.top = 0;
            overlay.style.left = 0;
            overlay.style.width = "100vw";
            overlay.style.height = "100vh";
            overlay.style.background = "rgba(30,39,46,0.85)";
            overlay.style.display = "flex";
            overlay.style.justifyContent = "center";
            overlay.style.alignItems = "center";
            overlay.style.zIndex = 2000;

            // Create calibration box
            const box = document.createElement("div");
            box.style.background = "#fff";
            box.style.borderRadius = "24px";
            box.style.padding = "36px 32px 28px 32px";
            box.style.boxShadow = "0 8px 32px rgba(30,200,180,0.18)";
            box.style.textAlign = "center";
            box.style.minWidth = "320px";
            box.style.position = "relative";
            box.style.animation = "popIn 0.5s";
            box.innerHTML = `
        <div style="
            margin: 0 auto 18px auto;
            border: 6px solid #f1f1f1;
            border-top: 6px solid #48dbfb;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            animation: spin 1s linear infinite;
        "></div>
        <h2 style="color:#10ac84;margin-bottom:12px;font-size:1.5em;font-weight:bold;">üß† Calibrating Your Brainwaves...</h2>
        <p style="color:#222f3e;font-size:1.1em;margin:10px 0;">Please stay focused. Measuring beta activity.</p>
        <p id="calibrationCountdownJS" style="font-size:2.5em;color:#48dbfb;font-weight:bold;margin-top:18px;letter-spacing:2px;">5</p>
    `;
            overlay.appendChild(box);
            document.body.appendChild(overlay);

            // Spinner animation
            const style = document.createElement('style');
            style.innerHTML = `
    @keyframes spin { 0% { transform: rotate(0deg);} 100% { transform: rotate(360deg);} }
    @keyframes popIn { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }
    `;
            document.head.appendChild(style);

            let secondsLeft = 5;
            const countdown = document.getElementById("calibrationCountdownJS");
            countdown.textContent = secondsLeft;

            const timer = setInterval(() => {
                secondsLeft--;
                countdown.textContent = secondsLeft;
                if (secondsLeft <= 0) {
                    clearInterval(timer);
                }
            }, 1000);

            calibrationInterval = setInterval(() => {
                const smoothBeta = smoother.getSmoothed('beta');
                betaValues.push(smoothBeta);
                if (smoothBeta > betaMaxDuringCalibration) {
                    betaMaxDuringCalibration = smoothBeta;
                }

                const now = performance.now();
                if (now - calibrationStartTime >= 5000) {
                    clearInterval(calibrationInterval);
                    // Find max value and its index
                    let max = -Infinity, maxIdx = -1;
                    betaValues.forEach((v, i) => {
                        if (v > max) {
                            max = v;
                            maxIdx = i;
                        }
                    });
                    console.log("Max index:", maxIdx, "Array length:", betaValues.length);

                    // Get previous two, max, next two values
                    const prev2 = betaValues[maxIdx - 2] !== undefined ? betaValues[maxIdx - 2] : null;
                    const prev1 = betaValues[maxIdx - 1] !== undefined ? betaValues[maxIdx - 1] : null;
                    const next1 = betaValues[maxIdx + 1] !== undefined ? betaValues[maxIdx + 1] : null;
                    const next2 = betaValues[maxIdx + 2] !== undefined ? betaValues[maxIdx + 2] : null;


                    // Calculate average of non-null values
                    const values = [prev2, prev1, max, next1, next2].filter(v => v !== null);
                    const avg = values.reduce((sum, v) => sum + v, 0) / values.length;


                    // Set beta threshold to 70% of max
                    betaMaxDuringCalibration = max * 0.7;
                    // Remove overlay
                    overlay.remove();
                    style.remove();
                    applyCalibratedThreshold();
                }
            }, 100);
        }

        function applyCalibratedThreshold() {
            betaThreshold = betaMaxDuringCalibration;
            thresholdDisplay.textContent = betaThreshold.toFixed(2);
            console.log("Calibration complete. Beta threshold set to:", betaThreshold.toFixed(2));

            // Create a temporary overlay message
            const msg = document.createElement('div');
            msg.className = 'calibration-message';
            msg.innerHTML = `
        <div style="
            background: #fff;
            border-radius: 20px;
            padding: 28px 36px;
            box-shadow: 0 4px 24px rgba(30,200,180,0.18);
            text-align: center;
            font-size: 1.3em;
            color: #10ac84;
            font-weight: bold;
        ">
            Calibration complete!<br>
            <span style="color:#222f3e;font-weight:normal;font-size:0.9em;">
                Beta threshold set to: <span style="color:#48dbfb;">${betaThreshold.toFixed(2)}</span>
            </span>
        </div>
    `;
            msg.style.position = 'fixed';
            msg.style.top = '50%';
            msg.style.left = '50%';
            msg.style.transform = 'translate(-50%, -50%)';
            msg.style.zIndex = 3000;
            msg.style.pointerEvents = 'none';

            document.body.appendChild(msg);

            setTimeout(() => {
                msg.remove();
                stepPosition = 0;
                goalReached = false;
                celebrationActive = false;
                updateShapePosition();
                setTimeout(() => {
                    shapeMovementAllowed = true; // <-- Allow movement now!
                }, 1000);
            }, 2500);
        }
        function updateShapePosition() {
            const arenaHeight = movingShape.parentElement.clientHeight - 140;
            const bottomPosition = 20 + (stepPosition / 100) * arenaHeight;
            movingShape.style.bottom = `${bottomPosition}px`;
            progressFill.style.height = `${stepPosition}%`;

            // Update percentage text
            const progressText = document.getElementById("progressPercentage");
            progressText.textContent = `${Math.round(stepPosition)}%`;

            // Color cues based on proximity
            if (stepPosition >= 90) {
                progressFill.style.backgroundColor = "#10ac84"; // Green
            } else if (stepPosition >= 60) {
                progressFill.style.backgroundColor = "#feca57"; // Yellow
            } else if (stepPosition >= 30) {
                progressFill.style.backgroundColor = "#ff9f43"; // Orange
            } else {
                progressFill.style.backgroundColor = "#ee5253"; // Red
            }
        }

        function animateStepChange(stepChange, stepSize = 1, delay = 100) {
            let target = stepPosition + stepChange;
            target = Math.max(0, Math.min(100, target)); // clamp between 0‚Äì100

            const direction = stepChange > 0 ? 1 : -1;

            const stepInterval = setInterval(() => {
                if ((direction > 0 && stepPosition >= target) ||
                    (direction < 0 && stepPosition <= target)) {
                    clearInterval(stepInterval);
                    if (stepPosition >= 100 && !goalReached) {
                        goalReached = true;
                        triggerCelebration();
                    }
                    return;
                }
                stepPosition += direction * stepSize;
                updateShapePosition();
            }, delay);
        }


        function triggerCelebration() {
            if (celebrationActive) return;
            celebrationActive = true;

            const goalZone = document.querySelector('.goal-zone');
            goalZone.className = 'goal-zone';
            goalZone.classList.add(`${currentShape.replace(/\s+/g, '-').toLowerCase()}-color`);

            // Merge shape into goal
            shapeElement.classList.add('shape-merging');

            // After merge animation
            setTimeout(() => {
                shapeElement.style.visibility = 'hidden'; // hide shape after merging

                // Increase goal count
                if (!gameWon) {
                    goalCount++;
                    document.getElementById('goalCount').textContent = goalCount;

                    if (goalCount >= 5) {
                        gameWon = true;
                        showWinningMessage();
                        return;
                    }
                }

                createFireworks();

                const successMsg = document.createElement('div');
                successMsg.className = 'success-message';
                successMsg.innerHTML = 'üéâ GOAL ACHIEVED! üéâ<br><small>Great focus!</small>';
                celebration.appendChild(successMsg);

                setTimeout(() => {
                    celebration.innerHTML = '';
                    celebrationActive = false;

                    // Reset visuals
                    setTimeout(() => {
                        shapePosition = 0;
                        goalReached = false;
                        goalZone.className = 'goal-zone';

                        // Reset shape
                        shapeElement.classList.remove('shape-merging');
                        shapeElement.style.visibility = 'visible';
                        updateShapePosition();
                        initializeShape();
                    }, 500); // slightly shorter delay
                }, 2500);
            }, 600); // match animation time
        }

        function showWinningMessage() {
            const winningMsg = document.createElement('div');
            winningMsg.className = 'winning-message';
            winningMsg.innerHTML = `
        üèÜ YOU WIN! üèÜ<br>
        <small>Amazing focus control!</small><br><br>
        <button id="playAgainBtn" style="
            margin-top: 20px;
            padding: 12px 32px;
            font-size: 1.2em;
            background: linear-gradient(90deg, #48dbfb, #1dd1a1);
            color: #fff;
            border: none;
            border-radius: 30px;
            box-shadow: 0 4px 16px rgba(30,200,180,0.15);
            cursor: pointer;
            transition: background 0.3s, transform 0.2s;
        ">üîÑ Play Again</button>
    `;
            document.body.appendChild(winningMsg);

            const playAgainBtn = document.getElementById('playAgainBtn');
            playAgainBtn.addEventListener('mouseover', () => {
                playAgainBtn.style.background = 'linear-gradient(90deg, #1dd1a1, #48dbfb)';
                playAgainBtn.style.transform = 'scale(1.05)';
            });
            playAgainBtn.addEventListener('mouseout', () => {
                playAgainBtn.style.background = 'linear-gradient(90deg, #48dbfb, #1dd1a1)';
                playAgainBtn.style.transform = 'scale(1)';
            });
            playAgainBtn.addEventListener('click', () => {
                window.location.reload();
            });
        }


        // Call initializeShape at the end of the script to start the game
        initializeShape();
        function createFireworks() {
            const colors = ['#ff6b6b', '#feca57', '#48dbfb', '#1dd1a1', '#ff9ff3'];
            const arenaRect = movingShape.parentElement.getBoundingClientRect();

            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    const firework = document.createElement('div');
                    firework.className = 'firework';
                    firework.style.background = colors[Math.floor(Math.random() * colors.length)];
                    firework.style.left = Math.random() * 100 + '%';
                    firework.style.top = Math.random() * 100 + '%';
                    celebration.appendChild(firework);

                    setTimeout(() => firework.remove(), 1000);
                }, i * 100);
            }
        }

        // Notch filter for 50Hz noise
        class Notch {
            constructor() {
                this.z1_1 = 0; this.z2_1 = 0;
                this.x_1 = 0;
                this.currentSamplingRate = 500;
            }
            setSamplingRate(rate) { this.currentSamplingRate = rate; }
            process(input, type) {
                if (!type) return input;
                let output = input;
                if (this.currentSamplingRate === 500 && type === 1) {
                    this.x_1 = output - (-1.56858163 * this.z1_1) - (0.96424138 * this.z2_1);
                    output = 0.96508099 * this.x_1 + -1.56202714 * this.z1_1 + 0.96508099 * this.z2_1;
                    this.z2_1 = this.z1_1;
                    this.z1_1 = this.x_1;
                }
                return output;
            }
        }
        let notchFilterCh0 = new Notch();
        notchFilterCh0.setSamplingRate(500);

        // FFT implementation
        class FFT {
            size;
            cosTable;
            sinTable;
            constructor(size) {
                this.size = size;
                this.cosTable = new Float32Array(size / 2);
                this.sinTable = new Float32Array(size / 2);
                for (let i = 0; i < size / 2; i++) {
                    this.cosTable[i] = Math.cos(-2 * Math.PI * i / size);
                    this.sinTable[i] = Math.sin(-2 * Math.PI * i / size);
                }
            }
            fft(real, imag) {
                const n = this.size;
                let j = 0;
                for (let i = 0; i < n - 1; i++) {
                    if (i < j) {
                        [real[i], real[j]] = [real[j], real[i]];
                        [imag[i], imag[j]] = [imag[j], imag[i]];
                    }
                    let k = n / 2;
                    while (k <= j) { j -= k; k /= 2; }
                    j += k;
                }
                for (let len = 2; len <= n; len *= 2) {
                    const half = len / 2;
                    for (let i = 0; i < n; i += len) {
                        for (let j = i, k = 0; j < i + half; j++, k++) {
                            const tRe = real[j + half] * this.cosTable[k] - imag[j + half] * this.sinTable[k];
                            const tIm = real[j + half] * this.sinTable[k] + imag[j + half] * this.cosTable[k];
                            real[j + half] = real[j] - tRe;
                            imag[j + half] = imag[j] - tIm;
                            real[j] += tRe;
                            imag[j] += tIm;
                        }
                    }
                }
            }
            computeMagnitudes(input) {
                const real = new Float32Array(this.size);
                const imag = new Float32Array(this.size);
                real.set(input);
                this.fft(real, imag);
                const mags = new Float32Array(this.size / 2);
                for (let i = 0; i < mags.length; i++) {
                    mags[i] = Math.hypot(real[i], imag[i]) / (this.size / 2);
                }
                return mags;
            }
        }

        const fftProcessor = new FFT(FFT_SIZE);


        const thresholdDisplay = document.getElementById('betaThresholdValue');



        function setDifficulty(level) {
            difficultyButtons.forEach(btn => btn.classList.remove('active'));

            const targetBtn = Array.from(difficultyButtons).find(
                btn => btn.dataset.level === level
            );

            if (targetBtn) {
                forwardStep = parseInt(targetBtn.dataset.stepforward || '10');
                backStep = parseInt(targetBtn.dataset.stepback || '5');
                targetBtn.classList.add('active');
            }

            console.log(`Difficulty set to ${level}: Forward=${forwardStep}, Back=${backStep}`);
        }
        difficultyButtons.forEach(button => {
            button.addEventListener('click', () => {
                const level = button.dataset.level;
                setDifficulty(level); // ‚úÖ Only pass level
            });
        });

        // Attach event listeners to all buttons
        difficultyButtons.forEach(button => {
            button.addEventListener('click', () => {
                const level = button.dataset.level;
                const threshold = parseFloat(button.dataset.threshold);
                const displayValue = button.querySelector('.btn-value').textContent.trim();
                setDifficulty(level, displayValue, threshold);
            });
        });

        // Set default to easy
        const defaultButton = document.querySelector('.difficulty-btn[data-level="easy"]');
        if (defaultButton) {
            const level = defaultButton.dataset.level;
            setDifficulty(level, "0.30", 0.30); // Always use 0.30
        }

        // Utility functions
        function normalizeSample(sample) {
            const a = 4096;
            return (sample - a / 2) * (2 / a);
        }

        function applyFilter(input, state) {
            state.x1 = input - (-1.47548044 * state.z1) - (0.58691951 * state.z2);
            const output = 0.02785977 * state.x1 + 0.05571953 * state.z1 + 0.02785977 * state.z2;
            state.z2 = state.z1;
            state.z1 = state.x1;
            return output;
        }

        function calculateBandPower(fftMagnitudes, freqRange) {
            const [startFreq, endFreq] = freqRange;
            const startIndex = Math.max(1, Math.floor(startFreq / FREQ_RESOLUTION));
            const endIndex = Math.min(Math.floor(endFreq / FREQ_RESOLUTION), fftMagnitudes.length - 1);
            let power = 0;
            for (let i = startIndex; i <= endIndex; i++) {
                power += fftMagnitudes[i] * fftMagnitudes[i];
            }
            return power;
        }

        // Band smoother class
        class BandSmoother {
            constructor(bufferSize) {
                this.bufferSize = bufferSize;
                this.buffers = {};
                this.sums = {};
                this.index = 0;

                ['delta', 'theta', 'alpha', 'beta', 'gamma'].forEach(band => {
                    this.buffers[band] = new Array(bufferSize).fill(0);
                    this.sums[band] = 0;
                });
            }

            updateAll(bandValues) {
                for (const band in bandValues) {
                    const val = bandValues[band];
                    this.sums[band] -= this.buffers[band][this.index];
                    this.sums[band] += val;
                    this.buffers[band][this.index] = val;
                }
                this.index = (this.index + 1) % this.bufferSize;
            }

            getSmoothed(band) {
                return this.sums[band] / this.bufferSize;
            }

            clear() {
                for (const band in this.buffers) {
                    this.buffers[band].fill(0);
                    this.sums[band] = 0;
                }
                this.index = 0;
            }
        }

        const smoother = new BandSmoother(128);

        // Replace updateBarGraph logic to use time thresholds
        function updateBarGraph(deltaP, thetaP, alphaP, betaP, gammaP) {
            const total = deltaP + thetaP + alphaP + betaP + gammaP;
            if (total <= 0) return;

            const rels = {
                delta: deltaP / total,
                theta: thetaP / total,
                alpha: alphaP / total,
                beta: betaP / total,
                gamma: gammaP / total
            };

            smoother.updateAll(rels);

            const smooth = {
                delta: smoother.getSmoothed('delta'),
                theta: smoother.getSmoothed('theta'),
                alpha: smoother.getSmoothed('alpha'),
                beta: smoother.getSmoothed('beta'),
                gamma: smoother.getSmoothed('gamma')
            };

            ['delta', 'theta', 'alpha', 'beta', 'gamma'].forEach(band => {
                const pct = Math.round(smooth[band] * 100);
                document.getElementById(`${band}Bar`).style.width = `${pct}%`;
                document.getElementById(`${band}Value`).textContent = `${pct}%`;
            });

            const currentTime = performance.now();

            if (!shapeMovementAllowed) return; // ‚úÖ movement locked during calibration/modal

            if (smooth.beta >= betaThreshold) {
                if (!lastAboveThresholdTime) lastAboveThresholdTime = currentTime;
                if (currentTime - lastAboveThresholdTime >= 2000) {
                    animateStepChange(forwardStep);
                    lastAboveThresholdTime = null;
                    lastBelowThresholdTime = null;
                }
            } else {
                if (!lastBelowThresholdTime) lastBelowThresholdTime = currentTime;
                if (currentTime - lastBelowThresholdTime >= 2000) {
                    animateStepChange(-backStep);
                    lastBelowThresholdTime = null;
                    lastAboveThresholdTime = null;
                }
            }
        }

        function processFFT() {
            if (fftBuffer.length < FFT_SIZE) return;
            const fftMags = fftProcessor.computeMagnitudes(fftBuffer);
            const deltaPower = calculateBandPower(fftMags, DELTA_RANGE);
            const thetaPower = calculateBandPower(fftMags, THETA_RANGE);
            const alphaPower = calculateBandPower(fftMags, ALPHA_RANGE);
            const betaPower = calculateBandPower(fftMags, BETA_RANGE);
            const gammaPower = calculateBandPower(fftMags, GAMMA_RANGE);
            updateBarGraph(deltaPower, thetaPower, alphaPower, betaPower, gammaPower);
        }

        function updateData(eegValue) {
            eegValue = notchFilterCh0.process(eegValue, 1);
            fftBuffer.push(eegValue);
            if (fftBuffer.length > FFT_SIZE) fftBuffer.shift();
            if (samplesReceived % 10 === 0) processFFT();
        }

        function processSample(dataView) {
            if (dataView.byteLength !== SINGLE_SAMPLE_LEN) return;

            const sampleCounter = dataView.getUint8(0);
            prevSampleCounter = sampleCounter;

            // Read EEG channel
            const rawEEG = dataView.getInt16(1, false);

            // Process EEG
            const normEEG = normalizeSample(Math.max(0, Math.min(4095, rawEEG)));
            const filteredEEG = applyFilter(normEEG, filterStateCh0);
            updateData(filteredEEG);
            samplesReceived++;
        }

        function handleIncomingSamples(event) {
            const value = event.target.value;
            if (value.byteLength === NEW_PACKET_LEN) {
                for (let i = 0; i < NEW_PACKET_LEN; i += SINGLE_SAMPLE_LEN) {
                    const sampleBuf = value.buffer.slice(i, i + SINGLE_SAMPLE_LEN);
                    processSample(new DataView(sampleBuf));
                }
            } else if (value.byteLength === SINGLE_SAMPLE_LEN) {
                processSample(new DataView(value.buffer));
            }
        }
        function clearBarGraph() {
            // for each band, reset width and label
            ['delta', 'theta', 'alpha', 'beta', 'gamma'].forEach(band => {
                document.getElementById(`${band}Bar`).style.width = '0%';
                document.getElementById(`${band}Value`).textContent = '';  // blank instead of ‚Äú0%‚Äù
            });
        }

        function updateButtonStates() {
            connectBtn.disabled = connected || streaming;
            disconnectBtn.disabled = !connected;
            startBtn.disabled = !connected || streaming;
            stopBtn.disabled = !streaming;

            if (!connected) statusText.textContent = "Not connected";
            else if (!streaming) statusText.textContent = "Connected but not streaming";
            else statusText.textContent = "Connected and streaming data";
        }

        async function connectBLE() {
            try {
                if (!navigator.bluetooth) {
                    alert("Web Bluetooth API not available. Use Chrome or Edge.");
                    return;
                }
                device = await navigator.bluetooth.requestDevice({
                    filters: [{ namePrefix: "NPG" }],
                    optionalServices: [SERVICE_UUID],
                });
                server = await device.gatt.connect();
                const service = await server.getPrimaryService(SERVICE_UUID);
                controlChar = await service.getCharacteristic(CONTROL_CHAR_UUID);
                dataChar = await service.getCharacteristic(DATA_CHAR_UUID);
                connected = true; streaming = false;
                fftBuffer = new Array(FFT_SIZE).fill(0);
                updateButtonStates();
                console.log("Device connected.");
            } catch (err) {
                console.log("Error:", err);
                alert("Connection error: " + err);
            }
        }

        async function disconnectBLE() {
            try {
                if (device && device.gatt.connected) {
                    if (streaming) await stopStream();
                    device.gatt.disconnect();
                }
                connected = false;
                streaming = false;
                updateButtonStates();
                clearBarGraph();
                stepPosition = 0;
                updateShapePosition();
                console.log("Device disconnected.");
            } catch (err) {
                console.log("Error disconnecting:", err);
            }
        }

        async function startStream() {
            try {
                if (!dataChar || !controlChar) return;

                await controlChar.writeValue(new TextEncoder().encode("START"));
                await dataChar.startNotifications();
                dataChar.addEventListener("characteristicvaluechanged", handleIncomingSamples);
                streaming = true;
                updateButtonStates();
                console.log("Streaming started.");

                // Reset game state
                stepPosition = 0;
                goalReached = false;
                celebrationActive = false;
                updateShapePosition();

                // Allow movement immediately (no calibration delay)
                shapeMovementAllowed = true;

            } catch (err) {
                console.log("Error starting stream:", err);
                alert("Error starting stream: " + err);
            }
        }

        async function stopStream() {
            try {
                if (dataChar && streaming) {
                    await dataChar.stopNotifications();
                    dataChar.removeEventListener("characteristicvaluechanged", handleIncomingSamples);
                    streaming = false;
                    updateButtonStates();
                    console.log("Streaming stopped.");
                }
                // Reset shape position to zero and update UI
                stepPosition = 0;
                updateShapePosition();
            } catch (err) {
                console.log("Error stopping stream:", err);
            }
        }

        // Event listeners for buttons
        connectBtn.addEventListener("click", connectBLE);
        disconnectBtn.addEventListener("click", disconnectBLE);
        startBtn.addEventListener("click", startStream);
        stopBtn.addEventListener("click", stopStream);

        // Add this after the DOM elements are defined
        const betaSlider = document.getElementById('betaSlider');

        // Add slider event listener
        betaSlider.addEventListener('input', function () {
            betaThreshold = parseFloat(this.value);
            betaThresholdValue.textContent = betaThreshold.toFixed(2);
            console.log('Beta threshold set to:', betaThreshold);
        });

        // Initialize threshold from slider
        betaThreshold = parseFloat(betaSlider.value);
    </script>
</body>

</html>